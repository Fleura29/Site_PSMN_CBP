.. _incns:

Logiciel INCNS - Parallel INCompressible Navier-Stokes solver
=============================================================

* **Contact** : Emmanuel Lévêque, Cerasela Calugaru 
* **Objectif** : Portage du code sur GPU avec CUDA : implémentation des transformées de Fourier rapide du code en utilisant la bibliothèque CuFFT sur GPU (dans un environnement PGI CUDA Fortran Compiler) à la place de de FFTw sur CPU. 

La percée relativement récente sur le marché des nouvelles architectures de calcul GPU étant prometteuse, la question du portage de codes sur de telles architectures est un domaine auquel le Centre Blaise Pascal s'intéresse, bien que le matériel et les logiciels associés sont encore loin d’atteindre une grande stabilité dans leur évolution et qu’on peut encore s’interroger sur la pérennité de ces outils.

Dans le cadre d’une collaboration avec Emmanuel Lêvèque (Laboratoire de Physique), nous désirons explorer les possibilités de portage du code de calcul IncNS. 

**Code de calcul IncNS** 

Ce code résout les équations de Navier-Stokes incompressibles dans un domaine cubique avec des conditions aux limites périodiques dans les trois directions. Il traite les deux dynamiques Eulérienne et Lagrangienne. Une force extérieure assure un stiring isotrope à faibles nombres d'ondes. Le code est principalement consacré à l'étude de la dynamique turbulente homogène et isotrope. L'intégration en temps est de deuxième ordre (schéma Adams-Bashforth), tandis que la discrétisation en espace est faite par une méthode pseudo-spectrale. L'intégration des trajectoires du fluide s'appuie sur un algorithme de Verlet de second ordre (en temps) et sur l'interpolation tri-cubique en espace. Le code s'exécute en parallèle (avec MPI) soit en simple ou double précision avec une option “dealiasing”. Pour le traitement des méthodes spectrales il utilise la transformée de Fourier rapide. 

**Développements au CBP** 

L’outil doxygen qui permet aussi la génération du graphe d’appels, nous a servis au CBP d’analyser le code et suite à un profilage du code, on est arrivés à la conclusion que dans un premier temps la partie du code la plus adaptée à porter sur GPU est la partie FFT. Dans le code originel, cette partie fait appel à la bibliothèque open source FFTw et plus précisément à des sousroutines permettant le traitement de plusieurs vecteurs à la fois.

Le code étant écrit en Fortan90, la méthode la plus naturelle qui a été envisagé pour porter cette partie de code a été d’utiliser les compilateurs commerciaux PGI CUDA. En effet, l’utilisation du langage CUDA ne semblait pas appropriée. Pour des tels codes, l’outil PGI CUDA développé par Portland Group en collaboration avec NVIDIA devrait théoriquement permettre le portage avec une quantité relativement réduite des modifications à apporter au code. En contrepartie, son application directe au code IncNS s’est avérée difficile dans ce contexte où la maturité du produit n’était pas encore achevée pour toutes ses fonctionnalités. En effet, dans les versions initiales (compatibles CUDA 3.2) de la librairie CuFFT (qui fait partie du produit PGI CUDA SDK) disponibles au début de nos travaux (2011), il n’y avait pas encore les sousroutines équivalentes à celles existantes dans la bibliothèque FFTw et utilisées dans IncNS pour le traitement simultané de plusieurs vecteurs. Etant donné que l’implantation de cette fonctionnalité était annoncée de façon imminente, il nous a paru plus raisonnable d’attendre cette évolution. Cependant, les versions ultérieures que j’ai testées (CUDA 4.0 et 4.1) n’ont pas entièrement intégré cette fonctionnalité, bien que quelques modifications (p.ex. rajout d'arguments des procédures, mais sans que ceux ci soient effectivement prisent en compte) ont été apportées. Pour toutes ces versions, il y a eu besoin d'installer de drivers et du SDK et nous avons effectué des tests de fonctionnement pour les diverses cartes GPU que nous avons eu temporairement à notre disposition (Tesla 1070 puis M2070). Les tests de performance sur les cartes GPU NVIDIA que nous avons effectués pour des transformées de Fourrier directes et inverses ont montré un speed-up intéressant lors du passage CPU vers GPU. L’acquisition de nouvelles cartes GPU et utilisation de la version actuelle CUDA 5 (une fois supportée dans les produits PGI) permettront la finalisation de ce travail d’optimisation du code sur ces architectures. 